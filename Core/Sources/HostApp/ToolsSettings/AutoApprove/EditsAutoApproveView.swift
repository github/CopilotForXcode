import AppKit
import Client
import Logger
import Preferences
import SharedUIComponents
import SwiftUI
import UserDefaultsObserver
import ComposableArchitecture

struct EditsAutoApproveView: View {
    @State private var isExpanded: Bool = true
    @StateObject private var viewModel = ViewModel()
    @State private var selection = Set<ViewModel.Rule.ID>()

    let rowHeight: CGFloat = 28

    private var canRemoveSelection: Bool {
        guard !selection.isEmpty else { return false }
        return !viewModel.rules.contains { rule in
            selection.contains(rule.id) && rule.isDefault
        }
    }

    var body: some View {
        VStack(spacing: 0) {
            DisclosureSettingsRow(
                isExpanded: $isExpanded,
                accessibilityLabel: { $0 ? "Collapse edits auto-approve section" : "Expand edits auto-approve section" },
                title: { Text("Edits Auto-Approve").font(.headline) },
                subtitle: { Text("Controls whether file edits generated by Copilot are approved automatically. Set to **true** to auto-approve edits to matching files; set to **false** to always require explicit approval.") }
            )

            if isExpanded {
                VStack(alignment: .leading, spacing: 0) {
                    Divider()

                    rulesTable

                    Divider()

                    toolbar
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(QuaternarySystemFillColor.opacity(0.75))
                .transition(.opacity.combined(with: .scale(scale: 1, anchor: .top)))
            }
        }
        .settingsContainerStyle(isExpanded: isExpanded)
        .onAppear {
            viewModel.loadRules()
        }
    }

    @ViewBuilder
    private var rulesTable: some View {
        if #available(macOS 13.5, *) {
            Table(viewModel.rules, selection: $selection) {
                TableColumn(Text("Pattern").bold()) { rule in
                    if rule.isDefault {
                        Text(rule.pattern).help(rule.pattern)
                    } else {
                        EditableText("Pattern", text: rule.pattern) { newText in
                            viewModel.updateRule(id: rule.id, pattern: newText)
                        }
                        .help("Click to edit pattern")
                    }
                }
                TableColumn("Description") { rule in
                    if rule.isDefault {
                        Text(rule.description).help(rule.description)
                    } else {
                        EditableText("Description", text: rule.description) { newText in
                            viewModel.updateRule(id: rule.id, description: newText)
                        }
                        .help(rule.description)
                    }
                }
                TableColumn("Type") { rule in
                    Text(rule.isDefault ? "Default" : "Custom")
                        .foregroundStyle(.secondary)
                }
                TableColumn("Auto-Approve") { rule in
                    Toggle(rule.isDefault ? "Default to false" : "", isOn: Binding(
                        get: { rule.autoApprove },
                        set: { viewModel.updateRule(id: rule.id, autoApprove: $0) }
                    ))
                    .disabled(rule.isDefault)
                }
            }
            .frame(height: CGFloat(max(viewModel.rules.count, 1)) * rowHeight + 40)
            .padding(.horizontal, 20)
            .transparentBackground()
        }
    }

    @ViewBuilder
    private var toolbar: some View {
        HStack(spacing: 8) {
            Button(action: { viewModel.addRule() }) {
                Image(systemName: "plus")
            }
            .foregroundColor(.primary)
            .buttonStyle(.borderless)
            .padding(.leading, 8)

            Divider()

            Group {
                if canRemoveSelection {
                    Button(action: {
                        viewModel.removeRules(ids: selection)
                        selection.removeAll()
                    }) {
                        Image(systemName: "minus")
                    }
                    .buttonStyle(.borderless)
                } else {
                    Image(systemName: "minus")
                }
            }
            .foregroundColor(
                canRemoveSelection ? .primary : Color(
                    nsColor: .quaternaryLabelColor
                )
            )
            .help("Remove selected rules")

            Spacer()
        }
        .frame(height: 24)
        .background(TertiarySystemFillColor)
    }
}

extension EditsAutoApproveView {
    final class ViewModel: ObservableObject {
        @Dependency(\.toast) var toast

        struct Rule: Identifiable {
            var id = UUID()
            var pattern: String
            var description: String
            var autoApprove: Bool
            var isDefault: Bool
        }

        @Published var rules: [Rule] = []
        private let defaults = UserDefaults.autoApproval
        private var observer = UserDefaultsObserver(
            object: UserDefaults.autoApproval,
            forKeyPaths: [UserDefaultPreferenceKeys().sensitiveFilesGlobalApprovals.key],
            context: nil
        )

        private let defaultRules: [Rule] = [
            Rule(pattern: "**/.github/instructions/*", description: "Github instructions files", autoApprove: false, isDefault: true),
            Rule(pattern: "**/github-copilot/**/*", description: "Github Copilot settings and token files", autoApprove: false, isDefault: true),
        ]

        init() {
            observer.onChange = { [weak self] in
                DispatchQueue.main.async {
                    self?.loadRules()
                }
            }
        }

        func loadRules() {
            var loadedRules: [Rule] = []

            // Load from UserDefaults
            let state = defaults.value(for: \.sensitiveFilesGlobalApprovals)
            let savedRules = state.rules

            func findExistingID(pattern: String) -> UUID {
                return rules.first(where: { $0.pattern == pattern })?.id ?? UUID()
            }

            // Add default rules first
            for defaultRule in defaultRules {
                var rule = defaultRule
                // If it exists in persisted config, override properties that can be changed (autoApprove)
                // We keep the default description unless we want to allow overriding it.
                if let savedRule = savedRules[defaultRule.pattern] {
                    rule.autoApprove = savedRule.autoApprove
                    if !savedRule.description.isEmpty {
                        rule.description = savedRule.description
                    }
                }
                rule.id = findExistingID(pattern: rule.pattern)
                loadedRules.append(rule)
            }

            // Add custom rules
            for (patternKey, value) in savedRules {
                // Skip if it's a default rule
                if defaultRules.contains(where: { $0.pattern == patternKey }) { continue }

                let id = findExistingID(pattern: patternKey)

                loadedRules.append(Rule(id: id, pattern: patternKey, description: value.description, autoApprove: value.autoApprove, isDefault: false))
            }

            rules = loadedRules.sorted {
                if $0.isDefault != $1.isDefault {
                    return $0.isDefault // Defaults first
                }
                return $0.pattern < $1.pattern
            }
        }

        func addRule() {
            var counter = 0
            var newPattern = "New Pattern"
            while rules.contains(where: { $0.pattern == newPattern }) {
                counter += 1
                newPattern = "New Pattern \(counter)"
            }
            rules.append(Rule(pattern: newPattern, description: "Description", autoApprove: false, isDefault: false))
            saveRules()
        }

        func removeRules(ids: Set<UUID>) {
            rules.removeAll { ids.contains($0.id) && !$0.isDefault }
            saveRules()
        }

        @discardableResult
        func updateRule(id: UUID, pattern: String? = nil, description: String? = nil, autoApprove: Bool? = nil) -> Bool {
            guard let index = rules.firstIndex(where: { $0.id == id }) else { return false }

            if let pattern {
                var newPattern = pattern.filter { !$0.isNewline }
                newPattern = newPattern.trimmingCharacters(in: .whitespacesAndNewlines)

                if !rules.contains(where: { $0.id != id && $0.pattern == newPattern }) {
                    rules[index].pattern = newPattern
                } else {
                    toast("Duplicate patterns are not allowed. Please ensure each rule has a unique pattern.", .warning)
                    return false
                }
            }
            if let description { rules[index].description = description }
            if let autoApprove { rules[index].autoApprove = autoApprove }

            saveRules()
            return true
        }

        func saveRules() {
            // Check for duplicate patterns
            let patterns = rules.map(\.pattern)
            let uniquePatterns = Set(patterns)
            if patterns.count != uniquePatterns.count {
                return
            }

            var state = defaults.value(for: \.sensitiveFilesGlobalApprovals)
            var newRules: [String: SensitiveFileRule] = [:]

            for rule in rules {
                newRules[rule.pattern] = SensitiveFileRule(description: rule.description, autoApprove: rule.autoApprove)
            }

            state.rules = newRules
            defaults.set(state, for: \.sensitiveFilesGlobalApprovals)
            Task {
                do {
                    let service = try getService()
                    try await service.postNotification(
                        name: Notification.Name
                            .gitHubCopilotShouldRefreshEditorInformation.rawValue
                    )
                } catch {
                    toast(error.localizedDescription, .error)
                }
            }
        }
    }
}
